\documentclass[es,practica]{uah}

\tema{2}
\titulo{Codificación de canal}{Lesson title}
%
\begin{document}

\titulacion{Optativa GIEC y GIT}
\departamento{Teoría de la Señal y Comunicaciones}
\asignatura{Comunicaciones Digitales}{}
\curso{2021/2022}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
\section{Introducción}
%%%%%%%%%%%%%%%%%%%%%%

Además de los ficheros de la Práctica 1, en esta práctica utilizaremos algunos archivos adicionales del directorio Python:

\begin{itemize}
	\item \texttt{Practica2.py}: Se trata del archivo principal que debemos ejecutar para desarrollar la práctica. Se trata de un ejemplo de codificación de canal con un archivo de texto como mensaje de entrada.
	\item \texttt{CodCanal.py}. Archivo con una serie de funciones relacionadas con la codificación de canal
	\begin{itemize}
		\item {\bf paridad\_cod}
		\item {\bf paridad\_dec}
		\item {\bf matrices\_hamming}
		\item {\bf hamming\_cod}
		\item {\bf hamming\_dec}
	\end{itemize}
	\item \texttt{Canal.py}. Archivo con las funciones necesarias para simular un canal de transmisión.
	\begin{itemize}
		\item {\bf canalAWGN}
	\end{itemize}		
\end{itemize}


Dentro del archivo \emph{FuncionesP2.py} veréis que faltan por desarrollar algunas funciones que se han dejado en blanco:
\begin{itemize}
	\item {\bf numErrores}: Esta función debe tomar a su entrada los mensajes a la entrada y a la salida del sistema en formato \emph{string} y devolver a su salida el número de errores detectados entre ambos:

	\item {\bf repeticion\_cod}: Esta función debe tomar a su entrada un mensaje en formato binario (\emph{String}), y el parámetro $k$ del codificador de repetición, y devolver a su salida el mensaje codificado. 

	\item {\bf repeticion\_dec}: Esta es la función inversa a la anterior. Dado un mensaje recibido del que sabemos que ha sido codificado con un código de repetición con parámetro $k$, debe devolver el mensaje binario decodificado, con los posibles errores corregidos. 
\end{itemize}







\section{¿Qué entregar?}
\begin{itemize}
	\item Todas las funciones creadas.
	\item Script del primer ejemplo de Matlab (códigos de repetición).
	\item Script del segundo ejemplo de Matlab (códigos de paridad).
	\item Script del tercer ejemplo de Matlab (códigos bloque), tanto con una señal aleatoria como con el texto.
\end{itemize}

\section{Apartado opcional}

Con todas las funciones que habéis generado, podéis probar cómo funcionarían para el caso de un fichero de sonido. 

Cargad el fichero de audio Brahms\_mono.wav. Utilizad para ello la función \texttt{audioread}, con el parámetro extra \texttt{'native'} para que se carguen las muestras en formato entero de 16 bits, que es el original.

Ahora vamos a transmitir esta señal por un canal con una probabilidad de error de bit de $0.0001$. Podéis escuchar el resultado utilizando las funciones \texttt{audioplayer} y \texttt{play}. 

Repetid ahora el proceso anterior pero introduciendo un codificador Hamming con $q=3$. Comprobad si se nota la mejoría en la calidad del sonido recibido. 



Una vez hayáis completado estas funciones ya podéis abrir el fichero \texttt{Practica2.py} y ejecutarlo. Comprobad que el fichero de salida (salida.txt) coincida con la entrada, y el número de errores producidos al final. Probad a variar la cantidad de ruido en el canal así como a comparar el resultado con otros codificadores de canal que tenéis disponibles en el código (paridad y Huffman).

\begin{itemize}
	\item El archivo \texttt{FuncionesP2.py}.
	\item Un documento de texto en el que se responda a lo siguiente:
	\begin{itemize}
		\item ¿Qué diferencias aprecias entre los distintos codificadores de canal en función de ruido en el canal?
	\end{itemize}
\end{itemize}



%\printindex
\end{document}



	
